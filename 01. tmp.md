## 3.3. Manejo de directorios y archivos <a name="directorios"><a/>  

> Ir al [Índice](#indice)

Antes de empezar a aprender los comandos necesarios para movernos y manejar directorios es necesario que conozcamos la estructura de directorios de Linux. 

Los sistemas GNU/Linux tienen un patrón bastante estricto y específico al respecto de la organización jerárquica de los directorios, definido por _Filesystem Hierarquy Standard_ (_FHS_), para evitar problemas de compatibilidad entre distribuciones y conseguir un sistema operativo sólido.  

La base de esta jerarquía es el directorio raíz (_root_), que se representa con el signo «/», y contiene al resto de directorios/archivos. 

Dentro del directorio raíz («/») encontramos varios directorios que posee funciones específicas para el sistema operativo. Los principales se describen en la siguiente tabla:


| Directorio  | Descripción                                                                                                                         |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------|
| /bin        | aplicaciones binarias importantes                                                                                                   |
| /boot       | Ficheros de configuración del arranque, núcleos y otros ficheros necesarios para el arranque (boot) del equipo.                     |
| /dev        | los ficheros de dispositivo                                                                                                         |
| /etc        | ficheros de configuración, scripts de arranque, etc.                                                                                |
| /home       | directorios personales (home) para los diferentes usuarios.                                                                         |
| /lib        | librerías del sistema (libraries)                                                                                                   |
| /media      | particiones montadas (cargadas) automáticamente en el disco duro y medios (media) extraíbles como CDs, cámaras digitales, etc.      |
| /mnt        | sistemas de archivos montados manualmente en el disco duro.                                                                         |
| /opt        | proporciona una ubicación donde instalar aplicaciones opcionales (de terceros)                                                      |
| /proc       | directorio dinámico especial que mantiene información sobre el estado del sistema, incluyendo los procesos actualmente en ejecución |
| /root       | directorio personal del usuario root (superusuario); también llamado "barra-root".                                                  |
| /sbin       | binarios importantes del sistema                                                                                                    |
| /sys        | archivos del sistema (system)                                                                                                       |
| /tmp        | temporary files                                                                                                                     |
| /usr        | aplicaciones y archivos a los que puede acceder la mayoría de los usuarios                                                          |
| /var        | archivos variables como archivos de registros y bases de datos                                                                      |  

Para más detalles ver: [Linux Fundation](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained), [Ayuda Linux](https://ayudalinux.com/estructura-sistema-archivos/) y [Ayuda Ubuntu](https://help.ubuntu.com/kubuntu/desktopguide/es/directories-file-systems.html).  

En este punto no es muy importante conocer los detalles de cada uno de estos directorios, ya que para hacer modificaciones en estos se requieren conocimientos más avanzados. 

El único directorio en el que nosotros vamos a trabajar en _home_, que contiene los archivos/directorios de cada uno de los usuarios (un mismo equipo con Linux puede tener más de un usuario definido, igual que en otros sistemas operativos). Cuando arrancamos el terminal o el visor de archivos generalmente nos llevará a la carpeta de nuestro usuario dentro de la carpeta _home_, por ejemplo, _/home/usuario/_. Para saber el directorio en el que nos encontramos podemos utilizar el comando _pwd_:

```bash
pwd

# Salida: /home/usuario
```

### Moverse entre directorios

Para cambiar de directorio utilizaremos el comando _cd_ (_change directory_). Por ejemplo, si queremos acceder a la carpeta _Descargas_ dentro de nuestra carpeta de usuario podemos escribir:

```bash
cd Descargas
```

Tras ello podemos comprobar con _pwd_ que ahora estamos en la carpeta _/home/usuario/Descargas/_.  

¿Qué ocurre si en lugar de _Descargas_ nos equivocamos y escribimos el nombre mal por error?  

```bash
cd descargas

# Salida: bash: cd: descargas: No existe el archivo o el directorio
```
> [!IMPORTANT]
> Efectivamente, Linux distingue entre mayúsculas y minúsculas, y por lo tanto, la carpeta _descargas_ no existe, y así nos lo indica el comando cuando lo ejecutamos.  

Para evitar este tipo de errores al escribir podemos hacer uso del tabulador (tecla TAB). Simplemente escribiendo las primeras letras del nombre de un archivo o directorio el terminal completará el nombre si sólo hay una opción, si hubiera más, pulsando TAB dos veces, te mostrará los nombre disponibles en el directorio actual. En el segundo caso podemos añadir alguna letra más del nombre y pulsar TAB para que se complete el nombre. Esto se conoce como _autocompletado_, y es muy útil para evitar errores.  

Bien, ahora que estamos en _/home/usuario/Descargas/_, ¿cómo vuelvo hacia atrás, a la carpeta anterior?  
Para ello usaremos uno de los 2 directorios especiales que hay dentro de cada directorio que vimos antes (ver [aquí](#dir_especiales)). En este caso usaremos el directorio ".." que hace referencia al directorio superior (_parent_), el que esta justo encima en la jerarquía:

```bash
cd ..
```

Ahora, si usamos _pwd_, podremos comprobar que hemos vuelto a _/home/usuario/_, y por lo tanto, hemos salido de la carpeta _Descargas_. 

Si queremos movernes varios niveles al mismo tiempo podemos encaderar la ruta a la que queremos entrar, Por ejemplo:

```bash
cd snap/firefox/common/
```

Y para ir hacia atrás varios directorios basta con encaderar ".." así:

```bash
cd ../../..
```

De este modo hemos ido 3 directorios hacia abajo en el jerarquía, hasta llegar a _/home/usuario/snap/firefox/common/_ y luego hemos subido 3 directorio para volver a _/home/usuario/_. 

Si ejecutamos el comando _cd_ sin ningún argumento (en este caso una ruta de un directorio) nos llegará a la carpeta _/home/usuario/_, que generalmente se refiero como _home_. También es posible hacer lo mismo con el caracter especial «~» (virgulilla, alt+4):

```bash
cd ~

# o podríamos usar este comodín en una ruta de directorios si no estamos en home

cd ~/snap/firefox/common/

# Esto es lo mismo que 
cd /home/usuario/snap/firefox/common/

# ~ = /home/usuario/

```

La otra carpeta especial que vimos anteriormente (".") hace referencia al directorio en el que estamos, es como decirle a la _shell_ que estamos aquí. Por lo tanto, podemos especificar un poco más al cambiar de directorio, borrar un directorio o un fichero, etc., añadiendo este punto en las instrucciones:

```bash
# Ejemplos- 
cd ./bia
rm -r ./bia
rm ./mi_fichero.txt
```
Esto no parece muy útil ahora mismo (a la par que inecesario), pero lo será necesario más adelante.

Por otro lado, si en lugar de movernos con _cd_, lo único que queremos es ver que hay en una carpeta podemos usar el comando _ls_ con la ruta que queremos explorar:

```bash
ls -lh snap/firefox/
# o
ls -lh ./snap/firefox/
# o
ls -lh ~/snap/firefox/
# o
ls -lh /home/usuario/snap/firefox/

# Todas son equivalentes
```
De esta manera veremos el contenido de la carpeta sin movernos de donde estamos.  

### Crear y borrar archivos y carpetas

Ahora vamos a crear un directorio con el comando _mkdir_ (_make directory_):

```bash
# vamos a home
cd
#
mkdir bia
```

Para eliminarlo usaremos el comando _rmdir_ (_remove directory_):
```bash
rmdir bia
```

> [!NOTE]
> _rmdir_ sólo sirve para eliminar directorios que estén vacíos.  

Vamos ahora a crear el directorio de nuevo, nos meteremos en este, y vamos a crear un fichero en su interior con el comando _touch_ y un subdirectorio:

```bash
mkdir bia
cd bia
touch mi_fichero.txt
mkdir sub_bia
cd ..
```
> [!NOTE]
> Es recomendable no usar espacios, tildes o caracteres especiales (¿?!$.., salvo "-" o "\_") en los nombres de archivos o directorios en Linux. 


Si ahora intentamos borrar el directorio con _rmdir_ nos a dará el siguiente error:

`rmdir: fallo al borrar 'bia': El directorio no está vacío`

Podemos entrar en el directorio _bia_ y borrar el archivo _mi_fichero.txt_ con el comando _rm_ (_remove_) y el subdirectorio _sub_bia_ con _rmdir_ (que está vacío)...

```bash
cd bia
rm mi_fichero.txt
rmdir sub_bia
cd ..
```

O, podemos hacer uso de la _-r_ del comando _rm_ que elimina el contenido de un directorio de manera recursiva, es decir, entra en el directorio y todos los subdirectorio y elimina todas los archivos y directorios que encuentre.  

```bash
rm -r bia
```

> [!WARNING]
> Lo que se borra en el terminal (a través de la _shell_) se elimina definitivamente, no va a ninguna papelera de reciclaje de la que podemos recuperar lo archivos o directorios. Por lo tanto, hay que estar muy seguro cuando se borra algo. Para evitar errores podemos usar la opción _-i_ de _rm_ para que nos pregunte antes de borrar si estamos seguros (_rm -i mi_fichero.txt_). Podríamos incluir un alias en _.bashrc_ como ya hicimos antes para que siempre nos pregunta y evitar problemas (_alias rm='rm -i'_).  


### Mover/renombrar y copiar archivos y directorios

Antes de empezar necesitamos crear algunos archivos y directorios:

```bash
cd
mkdir bia
cd bia
mkdir sub_bia
mkdir sub_bia_2
touch mi_fichero.txt
touch ./sub_bia_2/mi_fichero_2.txt
cd ~/bia
```

Podemos usar el comando _tree_ para ver la estructura del directorio que hemos creado:
```bash
tree .

# Salida:
# .
#├── mi_fichero.txt
#├── sub_bia
#└── sub_bia_2
#    └── mi_fichero_2.txt
```

Ahora vamos a hacer algunos movimientos de cosas. 

Si quremos mover _mi_fichero.txt_ a la carpeta _sub_bia_. Para ello usaremos el comando _mv_ (_move_):
```bash
mv mi_fichero.txt sub_bia

# mv ./mi_fichero.txt ./sub_bia
# También podemos añadir una barra (slash) al final de sub_bia para especificar que es un directorio
# mv ./mi_fichero.txt ./sub_bia/

tree .
# .
# ├── sub_bia
# │   └── mi_fichero.txt
# └── sub_bia_2
#     └── mi_fichero_2.txt
```

Para mover directorios se hace exáctamente igual. Vamos a mover _sub_bia_ dentro de _sub_bia_2_:

```bash
mv sub_bia sub_bia_2
# mv ./sub_bia ./sub_bia_2
# mv ./sub_bia/ ./sub_bia_2/
tree .
# .
# └── sub_bia_2
#     ├── mi_fichero_2.txt
#     └── sub_bia
#         └── mi_fichero.txt
```

Básicamente el comando _mv_ toma 2 argumentos (o más, ver más abajo), lo que queremos mover y dónde queremos moverlo.
¿Cómo muevo la carpeta _sub_bia_ fuera de _sub_bia_2_ donde estaba antes? Hay varias opciones:

```bash
# Escribiendo las rutas completas (o rutas absolutas)
mv /home/usuario/bia/sub_bia_2/sub_bia/ /home/usuario/bia/

# Usando la carpeta especial "." (desde /home/usuario/bia/, es decir, le decimos que mueva la carpeta a "aquí")
mv sub_bia_2/sub_bia .
# mv ./sub_bia_2/sub_bia .
# mv ./sub_bia_2/sub_bia/ .

# Usando la carpeta especial ".." (desde /home/usuario/bia/sub_bia_2/, es decir, le decimos que mueva la carpeta a la carpeta superior o parent)
cd sub_bia_2
mv sub_bia ..
# mv ./sub_bia ..
# mv ./sub_bia/ ..
```
Con ficheros, en lugar de directorios el comando _mv_ funciona exáctamente igual. También podemos mover más de una cosa a la vez. Para ello, le vamos a indicar varias cosas que queremos mover y por último el destino. Es decir, en este caso, el comando tomará más argumentos, siendo el último el destino. Vamos a mover los ficheros _mi_fichero.txt_ (dentro de _sub_bia_) y _mi_fichero_2.txt_ (dentro de _sub_bia_2_) a la carpeta superior (_bia_):

```bash
cd /home/usuario/bia
mv sub_bia/mi_fichero.txt sub_bia_2/mi_fichero_2.txt .
# mv /home/usuario/bia/sub_bia/mi_fichero.txt /home/usuario/bia/sub_bia_2/mi_fichero_2.txt /home/usuario/bia
tree .
#.
#├── mi_fichero_2.txt
#├── mi_fichero.txt
#├── sub_bia
#└── sub_bia_2
```

¿Cómo cambiamos el nombre a un archivo/directorio? 

Usando el comando _mv_, pero en lugar de ponerle un destino distinto al actual le indicamos el nuevo nombre que queremos darle. Obviamente este nuevo nombre debe ser único, que no exista un archivo o directorio con ese nombre, porque en el caso de existir lo que estamos haciendo en mover el archivo/directorio o en el peor de los casos estaremos sobre-escribiendo un archivo que ya existe. Vamos a renombrar _mi_fichero.txt_ a _mi_archivo.txt_:

```bash
mv mi_fichero.txt mi_archivo.txt
tree .
#.
#├── mi_fichero_2.txt
#├── mi_archivo.txt
#├── sub_bia
#└── sub_bia_2
```

Ahora vamos a renombrar el directorio _sub_bia_:

```bash
mv sub_bia sub_bia_1
tree .
#.
#├── mi_fichero_2.txt
#├── mi_archivo.txt
#├── sub_bia_1
#└── sub_bia_2
```

Las operaciones de renombrado y movimiento se pueden combinar, es decir, podemos mover y renombrar un fichero/directorio a la vez:

```bash
mv mi_fichero_2.txt ./sub_bia_2/mi_archivo_2.txt

tree .
#.
#├── mi_archivo.txt
#├── sub_bia_1
#└── sub_bia_2
#    └── mi_archivo_2.txt
```

Tomamos _mi_fichero_2.txt_ y le damos un nuevo destino en _sub_bia_2_ con un nuevo nombre _mi_archivo_2.txt_.  





> [!WARNING]
> Las extensiones de los archivos (_.txt_ o _.pdf_) en realidad son sólo una ayuda para que los programas pueden identificar los archivos que pueden abrir. 

<!--

Edición de ficheros
	ver ficheros
	Crear ficheros
	Editar ficheros

Permisos???
-->
