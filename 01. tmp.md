## 3.4. Manipulación de archivos <a name="ficheros"><a/>  

> Ir al [Índice](#indice)

Lo primero que debemos saber es que hay 2 grandes tipos de archivos que nos conciernen en este punto: 

- **Texto plano**: el contenido del archivo es directemente legible por un humano. Un ejemplo de este tipo de archivos sería los de tipo _txt_, _csv_, _tsv_ y muchos otros que se usan en secuenciación masiva para almacenar las secuencias (_fasta_, _fastq_, _sam_, _vcf_, etc.), que los veremos más adelante.  
- **Binarios**: el contenido del archivo sólo es entendible por un humano si se usa un programa especial para abrirlo. Un ejemplo sería un archivo de Microsotf Word (_docx_), cuyo contenido sólo es legible si usamos un editor de texto, ya sea el propio Microsoft Word u otro compatible (ex_ LibreOffice). También son parcialmente binarios los archivos _pdf_, _png_, _jpeg_, etc. Si trataramos de ver el contenido de estos ficheros con un editor de texto plano sólo veríamos una sucesión de caracteres ininteligibles para nosotros/as, pero perfectamente entendibles por un ordenador.  

Otra cosa importante que mencionar es que las extensiones de los archivos (_.txt_, _.pdf_) sólo sirven para que el sistem operativo sepa con qué programa específico debe abrirlos.  

La mayoría de los archivos que vamos a manejar serán de tipo _texto plano_ y a veces estarán comprimidos para ocupar menos espacio (lo que los convierte en binarios).  

Ya hemos visto antes cómo crear un archivo vacío con el comando _touch_, pero hay otra formas de crear archivos, principalmente redirigiendo la salida estándar (_stdout_) de algún comando.  

Cuando ejecutamos un comando en el terminal, si este genera algún tipo de salida, se muestra en la pantalla del terminal, siendo esta la salida estándar por defecto. Utilizando el operados «>» podemos redirigir lo que se muestra por pantalla a un archivo. Para este ejemplo usaremos el comando _echo_ que muestra por pantalla el texto que le demos (también puede mostrar el contenido de una variable):

```bash
cd
cd bia
echo "Esto es una prueba" > nuevo_archivo.txt
```

Ahora podemos comprobar con _ls_ o _tree_ que hemos creado un nuevo archivo. En este caso, a diferencia de los anteriores en los que usamos el comando _touch_ para crearlos, el nuevo archivo no está vacío, lo que podemos comprobar por el espacio que ocupa:

<p align="center" width="100%">
	<img width="50%" src="./images/echo.png">
</p>

Si quisiéramos añadir algún texto a nuestro archivo de manera rápida podríamos usar también el comando _echo_, pero ahora, en lugar de usar al operador «>», que crearía un nuevo archivo sobre-escribiendo el que ya existe si usamos el mismo nombre, usaremos el operador «>>» que añade el nuevo contenido al archivo existente (si usamos este operador con el nombre de un fichero que no existe, se crear también y se añade el contenido):

```bash
echo "Voy a añadir nueva información" >> nueva_archivo.txt
```

Otra forma de crear, o editar, un archivo desde el terminal es usando diversos editores de texto plano que vienen ya pre-instalador en la _shell_. Los más habituales son _vim_, más antiguo y difícil de manejar pues debes conocer los atajos de teclado para operar, y _nano_ que es más intuitivo. Vamos a ver y editar nuestro archivo con _nano_:

```bash
nano nuevo_archivo.txt

# Añadimos o modificamos lo que queremos
# Para guardar pulsamos ctrl+o
# Para salir pulsamos ctrl+x
```

<p align="center" width="100%">
	<img width="75%" src="./images/nano3.png">
</p>


Como vemos en la parte inferior del editor tenemos una chuleta con los comandos que podemos usar, como guardar, cerrar, cortar y pegar, etc. La tecla _ctrl_ está simbolizada como «^» para ahorrar espacio. 


En lugar de editar un archivo que ya existe podemos crear uno nuevo escribiendo el nombre de un nuevo archivos que no exista:

```bash
nano nuevo_archivo_2.txt
```

Sin embargo, generalmente los archivos que vamos a manejar no son tan simples, por lo que para aprender los comandos más habituales para ver el contenido y analizar el contenido de un fichero de texto plano vamos a utilizar el archivo «countries.csv» (modificado de [aquí](https://simplemaps.com/data/countries)) y que tenéis disponible en la carpeta _/home/usuario/Documentos/_. Para no borrar accidentalmente el archivo vamos a hacernos una copia en una nueva carpeta:

```bash
cd
mkdir countries
cp /home/usuario/Documentos/countries.tsv countries
cd countries
```

Vamos a echar un vistazo al contenido del archivo con el comando _less_, que no muestra el contenido en trozos del tamaño de la ventana del terminal, que podremos ir moviendo con las fechas o con la barra de espacio. 

```bash
less countries
```

Quizás cuesta un poco, pero se puede intuir que estamos ante una tabla, lo que ya se podía intuir por su extensión _tsv_ (_tab separated values_, valores separados por tabuladores). Existe otro tipo de tablas en formato texto plano que sería el _csv_ (_comma separated values_, valores separados por comas), siendo ambos formatos importables en Microsoft Excel (o LibreOffice).  

En la visualización en el terminal a veces las columnas están un poco desfasadas dependiendo el tamaño del texto de cada "celda", por lo que no siempre es fácil verlo. En cualquier caso, estamos ante una tabla de paises con varios datos de cada uno de ellos (moneda usado, población, etc.). En la siguiente tabla podemos ver algo mejor las primers líneas del archivo.  

| country       | currency             | population | density | area     | gdp      | language   | driving_side | continent     | un_member | religion     |
|---------------|----------------------|------------|---------|----------|----------|------------|--------------|---------------|-----------|--------------|
| China         | Chinese Yuan         | 1413142846 | 147.2   |  9596960 | 17963170 | Chinese    | right        | Asia          |    TRUE   | No Religion  |
| India         | Indian Rupee         | 1399179585 | 425.6   |  3287263 |  3465541 | Hindi      | left         | Asia          |    TRUE   | Hinduism     |
| United States | United States Dollar |  339665118 | 34.5    |  9833517 | 25744100 | English    | right        | North America |    TRUE   | Christianity |
| Indonesia     | Rupiah               |  279476346 | 146.7   |  1904569 |  1319100 | Indonesian | left         | Asia          |    TRUE   | Islam        |
| Pakistan      | Pakistani Rupee      |  247653551 | 311.1   |   796095 |   326796 | Urdu       | left         | Asia          |    TRUE   | Islam        |
| Nigeria       | Naira                |  230842743 | 249.9   |   923768 |    15414 | English    | right        | Africa        |    TRUE   | Christianity |
| Brazil        | Brazilian Real       |  218689757 |    25.7 |  8515770 |  1920095 | Portuguese | right        | South America |    TRUE   | Christianity |
| Bangladesh    | Bangladeshi Taka     |  167184465 |  1126.1 |   148460 |   432677 | Bengali    | left         | Asia          |    TRUE   | Islam        |
| Russia        | Russian Ruble        |  141698923 |     8.3 | 17098242 |  2240422 | Russian    | right        | Europe        |    TRUE   | Christianity |

Para salir de la visualización del archivo que estamos haciendo con _less_ debemos pulsar la tecla «q» (_quit_) o _ctrl+c_ (_cancel_). 


Si sólo queremos echar un vistazo al inicio del archivo podemos usara el comando _head_, que por defecto nos muestra las primeras 10 líneas, pero que podemos modificar usando la opción _-n_ para mostrar las primeras n líneas que necesitemos:

```bash
head -n 5 countries.tsv

# country	currency	population	density	area	gdp	language	driving_side	continent	un_member	religion
# China	Chinese Yuan	1413142846	147.2	9596960	17963170	Chinese	right	Asia	TRUE	No Religion
# India	Indian Rupee	1399179585	425.6	3287263	3465541	Hindi	left	Asia	TRUE	Hinduism
# United States	United States Dollar	339665118	34.5	9833517	25744100	English	right	North America	TRUE	Christianity
# Indonesia	Rupiah	279476346	146.7	1904569	1319100	Indonesian	left	Asia	TRUE	Islam
```

_tail_ funciona igual que _head_, pero nos mostrará las n últimas líneas (por defecto 10):

```bash
tail -n 5 countries.tsv

# South Georgia and the South Sandwich Islands	Pound Sterling					English	left	Seven seas (open ocean)	FALSE	
# Heard Island and McDonald Islands				412			left	Seven seas (open ocean)	FALSE	
# Bouvet Island				49			right	Antarctica	FALSE	
# Antarctica				14200000				Antarctica	FALSE	No Religion
#
```

Como vemos, sólo nos muestra 4 líneas con contenido porque hay una última línea en blanco al final del archivo.


Podríamos combinar estos comandos, y otros, usando lo que se conoce como _pipes_, o tuberías, que básicamente permiten pasar la salida de un comando al siguiente. Por ejemplo, imaginamos que queremos copiar la información de India, que está en la tercera línea del fichero. Obviamente podríamos abrirlo con _nano_ y copiar la tercera línea, pero no siempre vamos a poder hacer esto por el tamaño de lso archivos, que podrían llegar a no abrirse con _nano_ (o _vim_) o tardarían demasiado. Para hacerlo rápido podemos tomar las 3 primeras líneas con _head_ y luego pasar esas líneas a _tail_ y pedirle que nos devuelva sólo la última. Esto se ehecutaría así:

```bash
head -n 3 countries.tsv | tail -n 1

# India	Indian Rupee	1399179585	425.6	3287263	3465541	Hindi	left	Asia	TRUE	Hinduism
```

Hemos utilizado el operador «|» (_pipe_) para separar los comandos que se escribe pulsando alt+1. Veremos más adelante que podemos combinar muchos comandos usando _pipes_.  

Si quisiéramos guardar el resultado del comando anterior en un archivo se podrían añadir al final el operador «>» y darle el nombre que queramos al nuevo archivo:

```bash
head -n 3 countries.tsv | tail -n 1 > india.txt
```

En este caso no obtenemos ningún resultado por pantalla, ya que hemos redirigido la salida estándar (la pantalla del terminal) a un archivo («>») creando un nuevo archivo con la información. 

Supongamos ahora que queremos ver la información del medio de la tabla, por ejemplo Senegal. Podemos usar _less_ e ir buscando línea a línea hasta encontrar lo que buscamos o podemos usar un comando para hacerlo más rápido. En este caso vamos a utilizar el comando _grep_ que nos permite buscar texto (con o sin comodines, _wildcards_) en el contenido de un archivo. La sintaxis es sencilla, le decimos qué queremos buscar y dónde:

```bash
grep senegal countries.tsv
```

Nada, no nos devuelve nada. ¿Por qué? 

> [!IMPORTANT]
> Por que en Linux "senegal" no es lo mismo que "Senegal", es decir, Linux diferencia mayúsculas de minúsculas (en Windows y Mac esto no es así). 

Entonces podemos repetir la búsqueda con "Senegal" o bien, si no sabemos cómo está escrito en la tabla, podemos usar la opción «-i» de _grep_ que lo hace insensible a las mayúsculas/minúsculas:

```bash
grep -i senegal countries.tsv

# Senegal	West African Cfa Franc	18384660	93.5	196722	27775	French	right	Africa	TRUE	Islam
```

Ahora sí obtenemos el resultado deseado. 

Vale, pero y si no tenemos muy claro como se escribe el nombre de un país. Por ejemplo, en español Zimbabue se escribe así, pero y en inglés o en Shona (el idioma oficial de este país)... Probablemente no sea muy diferente, así que podemos hacer búsquedas con textos parciales, por ejemplo, solo "zi":

```bash
grep -i zi countries.tsv

#Brazil	Brazilian Real	218689757	25.7	8515770	1920095	Portuguese	right	South America	TRUE	Christianity
#Zimbabwe	Zimbabwean ZiG	15418674	39.5	390757	26418	English	left	Africa	TRUE	Christianity
```
Vemos que ha encontrado "zi" en 2 líneas de la tabla: Bra**zi**l y **Zi**mbabwe. 

Supongamos ahora que nos interesa saber qué paises se llaman "United lo que sea". Pero no tengo muy claro si "united" lleva una o 2 "t". Podríamos hacer la siguiente búsqueda:

```bash
grep -i unit* countries.tsv

```

Como vemos en la tabla de debajo con los resultados de la búsqueda anterior, tenemos algunos resultados de paises que su nombre no empieza por "united", si no que _grep_ ha encontrado el patrón _unit*_ en otras partes, mayoritariamente en la moneda usada por el país:

| United States                        | United States Dollar        | 339665118 | 34.5  | 9833517 | 25744100 | English    | right | North America           |  TRUE | Christianity |
|--------------------------------------|-----------------------------|----------:|-------|--------:|---------:|------------|-------|-------------------------|:-----:|--------------|
| United Kingdom                       | British Pound               |  68138484 | 279.7 |  243610 |  3089072 | English    | left  | Europe                  | FALSE | Christianity |
| Ecuador                              | United States Dollar        |  17483326 | 61.7  |  283561 |   115049 | Spanish    | right | South America           |  TRUE | Christianity |
| Tunisia                              | Tunisian Dinar              |  11976182 | 73.2  |  163610 |    46181 | Arabic     | right | Africa                  |  TRUE | Islam        |
| United Arab Emirates                 | United Arab Emirates Dirham |   9973449 | 119.3 |   83600 |   507063 | Arabic     | right | Asia                    |  TRUE | Islam        |
| El Salvador                          | United States Dollar        |   6602370 | 313.8 |   21041 |    32488 | Spanish    | right | North America           |  TRUE | Christianity |
| Panama                               | United States Dollar        |   4404108 | 58.4  |   75420 |    76522 | Spanish    | right | North America           |  TRUE | Christianity |
| Puerto Rico                          | United States Dollar        |   3057311 | 335.8 |    9104 |   113434 | Spanish    | right | North America           | FALSE | Christianity |
| Timor-Leste                          | United States Dollar        |   1476042 | 99.2  |   14874 |     3204 | Portuguese | left  | Asia                    |  TRUE | Christianity |
| Guam                                 | United States Dollar        |    169330 | 311.3 |     544 |          | English    | right | Oceania                 | FALSE | Christianity |
| United States Virgin Islands         | United States Dollar        |    104917 | 54.9  |    1910 |          | English    | left  | North America           | FALSE | Christianity |
| Federated States of Micronesia       | United States Dollar        |    100319 | 142.9 |     702 |      427 | English    | right | Oceania                 |  TRUE | Christianity |
| Marshall Islands                     | United States Dollar        |     80966 | 447.3 |     181 |      279 | English    | right | Oceania                 |  TRUE | Christianity |
| Turks and Caicos Islands             | United States Dollar        |     59367 | 62.6  |     948 |     1138 | English    | left  | North America           | FALSE | Christianity |
| Northern Mariana Islands             | United States Dollar        |     51295 | 110.5 |     464 |          | English    | right | Oceania                 | FALSE | Christianity |
| American Samoa                       | United States Dollar        |     44620 | 199.2 |     224 |      709 | English    | right | Oceania                 | FALSE | Christianity |
| British Virgin Islands               | United States Dollar        |     39369 | 260.7 |     151 |          | English    | left  | North America           | FALSE | Christianity |
| Caribbean Netherlands                | United States Dollar        |     30397 |       |         |      725 | English    | right | North America           | FALSE | Christianity |
| Palau                                | United States Dollar        |     21779 | 47.4  |     459 |      225 | English    | right | Oceania                 |  TRUE | Christianity |
| United States Minor Outlying Islands | United States Dollar        |       300 |   6.1 | 49.26   |          | English    | right | North America           | FALSE | Christianity |
| British Indian Ocean Territory       | United States Dollar        |           |       |      60 |          | English    | right | Seven seas (open ocean) | FALSE | Islam        |
| Réunion                              | Euro                        |           |       |         |          | French     | right | Africa                  | FALSE | Christianity |

Pero eso no es lo que queríamos. ¿Cómo le decimos a _grep_ que busque en el nombre de los paises? Pues sabemos que el nombre del país es lo primero que parece en la tabla, luego, le podemos decir a _grep_ que busque al patrón justo al principio usando el operador «^» al inicio del patrón:

```bash
grep -i ^unit* countries.tsv

# United States	United States Dollar	339665118	34.5	9833517	25744100	English	right	North America	TRUE	Christianity
# United Kingdom	British Pound	68138484	279.7	243610	3089072	English	left	Europe	FALSE	Christianity
# United Arab Emirates	United Arab Emirates Dirham	9973449	119.3	83600	507063	Arabic	right	Asia	TRUE	Islam
# United States Virgin Islands	United States Dollar	104917	54.9	1910		English	left	North America	FALSE	Christianity
# United States Minor Outlying Islands	United States Dollar	300	6.1	49.26		English	right	North America	FALSE	Christianity

```

También podemos usar el operador «$» para buscar patrones que estén justo al final de cada línea. Por ejemplo, cuántos paises tienen como religión el Islam:

```bash
grep -i islam$ countries.tsv
```

¿Cuántos hay? Muchos... ¿Cómo podemo contarlos? ¿Manualmente? 

Usaremos el comando _wc_ (_word count_). Vas a ver primero cuántos paises hay en nuestra base de datos:

```bash
wc countries.tsv

# 255  3173 22161 countries.tsv
```

_wc_ no devulve, en este órden: el número de líneas, el número de palabras y el número de caracteres. 

Entonces tenemos 255 líneas en nuestra tabla, pero hay que restar 1 línea de la cabecera de la tabla, por lo tanto, tenemos 254 paises en la tabla.  

Si sólo estamos interesados en conocer el número de líneas podemos usar la opción «-l», o «-w» para las palabras o «-m» para caracteres. 

Ahora que ya sabemos contar líneas volvemos a la pregunta de cuántos paises tienen el Islam como religión principal. Vamos a pasarse a _wc_ la salida de _grep_ usando _pipes_:

```bash
grep -i islam$ countries.tsv | wc -l 

# 56
```

<!-- guardar salida a archivo nuevo 

wc, grep 


-->

<!--
> [!WARNING]
> Las extensiones de los archivos (_.txt_ o _.pdf_) en realidad son sólo una ayuda para que los programas pueden identificar los archivos que pueden abrir. 

			cat (comprimir con gzip, zcat)

Otro comando útil para ver el contenido de lo archivos es _cat_ (_concatenate_, concatenar) que muestra el contenido completo del archivo en la plantalla. Este comando, aunque sirve para ver el contenido, dado que lo muestra por completo es más útil para 





			Compresión/descompresión
			# No da tiempo cut, sed, sort, uniq, awk, etc....



Permisos???
-->
